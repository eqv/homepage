<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Hexgolems</title>
    <link>https://hexgolems.com/tags/rust/</link>
    <description>Recent content in Rust on Hexgolems</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hexgolems.com/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>gdb_probe.rs</title>
      <link>https://hexgolems.com/2019/02/gdb_probe.rs/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/02/gdb_probe.rs/</guid>
      <description>View On Github
You love ipdb.set_trace() in python or binding.pry in ruby? You are sad that rust doesn&amp;rsquo;t offer the same comfort? gdb_probe.rs is here to safe the day! With a simple call, it suspends the current process, spawns a new terminal and attaches gdb. This has many advantages:
 Comfortable debugging. If you program in an IDE with limited debugger support, you get a much simpler debugging story than manually using gdb.</description>
    </item>
    
    <item>
      <title>HexTD</title>
      <link>https://hexgolems.com/2019/01/hextd/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/01/hextd/</guid>
      <description>View On Github
HexTD is a Tower Defense game that features deck building mechanics similar to the board game Dominion. It was written in Rust together with a friend as a learning project. It allready features the complete set of deck building mechanics, a shop to aquire new cards, enemies, towers and buff cards as well as a set of cards that allow to interact with the gameplay itself. It is based on the ggez library.</description>
    </item>
    
    <item>
      <title>Nautilus - Fuzzing with Grammars</title>
      <link>https://hexgolems.com/2018/12/nautilus---fuzzing-with-grammars/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2018/12/nautilus---fuzzing-with-grammars/</guid>
      <description>View On Github
Nautilus   Authors: Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig, Ahmad-Reza Sadeghi, Daniel Teuchert
Nautilus is a feedback fuzzer inspired by AFL. However it allows to specify a grammar. Using this grammar, the fuzzer generates and internally uses the abstract syntax tree of the input. This also allows for very complex mutations. Then it converts the tree to the actual input. Knowing the exact tree shape greatly improves the performance for highly structured input formats, such as many text formats and programming languages.</description>
    </item>
    
    <item>
      <title>Interval Tree</title>
      <link>https://hexgolems.com/2017/05/interval-tree/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/05/interval-tree/</guid>
      <description>View On Github
When implementing analysis software for memory dumps one often needs to store information on ranges of memory. For example, one might want to store ranges that represent basic blocks or functions, in code or memory allocations and type information in memory dumps. Afterwards one might want to answer queries such as &amp;ldquo;give me all allocations intersecting some range (x,y)&amp;rdquo;. In particular, this crate can be used to create better hex editor views, incorporating additional information.</description>
    </item>
    
    <item>
      <title>Loaded Dice</title>
      <link>https://hexgolems.com/2017/02/loaded-dice/</link>
      <pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/02/loaded-dice/</guid>
      <description>View On Github
Sometimes you need to sample from a set of options. This crate allows you to sample from discrete probability distributions efficiently (O(1) per sample).
It implements a random sampler implementing based on the alias method (https://en.wikipedia.org/wiki/Alias_method). One uses it by passing a vector of probabilites to the constructor. The constructor builds a data structure in O(n*n*log(n)) (Note: It would be quite possible to implement this in O(n*log(n)), however for reasonable sized number of values this method is faster than using the more effictient data strucutres.</description>
    </item>
    
  </channel>
</rss>