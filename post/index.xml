<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hexgolems</title>
    <link>https://hexgolems.com/post/</link>
    <description>Recent content in Posts on Hexgolems</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hexgolems.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Incorrectness Logic by Example</title>
      <link>https://hexgolems.com/2020/04/incorrectness-logic-by-example/</link>
      <pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2020/04/incorrectness-logic-by-example/</guid>
      <description>Incorrectness Logic by Example Incorrectness Logic is a formal method to reason about program behavior. Similar formal reasoning techniques have been used for a multitude of different tasks in program verification, bug hunting and exploitation. To give some examples, Symbolic Execution (SE) has been used to generate hundreds of working exploits against a (at that time) current version of Debian [1]. While possible, it is often difficult to scale SE with all its precision to large targets.</description>
    </item>
    
    <item>
      <title>Nautilus 2.0</title>
      <link>https://hexgolems.com/2020/04/nautilus-2.0/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2020/04/nautilus-2.0/</guid>
      <description>View On Github
Nautilus 2.0 We are glad to announce the released of v2.0 of our fuzzer Nautilus!
Nautilus is a coverage guided, grammar based fuzzer. You can use it to improve your test coverage and find more bugs. By specifying the grammar of semi valid inputs, Nautilus is able to perform complex mutation and to uncover more interesting test cases. Many of the ideas behind this fuzzer are documented in a Paper published at NDSS 2019.</description>
    </item>
    
    <item>
      <title>HotFuzz</title>
      <link>https://hexgolems.com/2019/12/hotfuzz/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/12/hotfuzz/</guid>
      <description>In this Presentation at Blackhat London 2019, Sergej and I present the results of the last 3 years of our fuzzing research. Besides presenting details on super fast vm reloads and a whole bunch of other proejects, we also try to predict research topics will be interesting to explore further in the next few years.
   Talk Slides     Video will be linked when published     Authors: Cornelius Aschermann, Sergej Schumilo</description>
    </item>
    
    <item>
      <title>Fast Cov</title>
      <link>https://hexgolems.com/2019/11/fast-cov/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/11/fast-cov/</guid>
      <description>View On Github
Fast binary coverage using Qemu and a Forkserver You want to inspect the coverage produced by your fuzzer, but kcov/gcov are slow and require special builds of the target? You misplaced the sourcecode and can&amp;rsquo;t even build the target with coverage instrumentation?
cov.py to the rescue!
Based on AFL&amp;rsquo;s Qemu mode, cov.py quickly produces edge coverage information on binary targets. It uses the AFL&amp;rsquo;s forkserver to speed up coverage calculation massively and generates precise trace files.</description>
    </item>
    
    <item>
      <title>Hexslides: Death to Death by Powerpoint!</title>
      <link>https://hexgolems.com/2019/08/hexslides-death-to-death-by-powerpoint/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/08/hexslides-death-to-death-by-powerpoint/</guid>
      <description>View On Github
Hexslides allows you to create presentations with highly expressive animations in your favorite vector graphic drawing tool (such as Inkscape). Then you combine svg graphics and masters/templates in beautiful presentations.
Create highly visual presentations, that support what you are talking about instead of distracting from it! Easily create animations to better present your ideas!         Use textex for your math typesetting needs, and combine them with easy, manual layouting for complex situations and animations!</description>
    </item>
    
    <item>
      <title>Antifuzz</title>
      <link>https://hexgolems.com/2019/07/antifuzz/</link>
      <pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/07/antifuzz/</guid>
      <description>Antifuzz   Authors: Emre Güler, Cornelius Aschermann, Ali Abbasi, Thorsten Holz
In this work, we analysed various state of the art fuzzers and show that common obfuscation techniques do not help against attackers using fuzzer. Then we systematically attack the underlying assumptions of modern fuzzers and show how they can be attacked by relatively simple obfuscations mechanisms.</description>
    </item>
    
    <item>
      <title>Grimoire</title>
      <link>https://hexgolems.com/2019/07/grimoire/</link>
      <pubDate>Wed, 17 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/07/grimoire/</guid>
      <description>View On Github
Grimoire   Authors: Tim Blazytko, Cornelius Aschermann, Ali Abbasi, Sergej Schumilo, Simon Wörner, Thorsten Holz
Grimoire is a fast binary only fuzzer, that infers structural information during the fuzzing process itself. To produce better test coverage, it it observes how chunks from the learned inputs can be recombined in a weak form of grammar. This process piggybacks on the usual fuzzing process. It only uses the information obtained from a AFL-style feedback bitmap.</description>
    </item>
    
    <item>
      <title>gdb_probe.rs</title>
      <link>https://hexgolems.com/2019/02/gdb_probe.rs/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/02/gdb_probe.rs/</guid>
      <description>View On Github
You love ipdb.set_trace() in python or binding.pry in ruby? You are sad that rust doesn&amp;rsquo;t offer the same comfort? gdb_probe.rs is here to safe the day! With a simple call, it suspends the current process, spawns a new terminal and attaches gdb. This has many advantages:
 Comfortable debugging. If you program in an IDE with limited debugger support, you get a much simpler debugging story than manually using gdb.</description>
    </item>
    
    <item>
      <title>HexTD</title>
      <link>https://hexgolems.com/2019/01/hextd/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2019/01/hextd/</guid>
      <description>View On Github
HexTD is a Tower Defense game that features deck building mechanics similar to the board game Dominion. It was written in Rust together with a friend as a learning project. It allready features the complete set of deck building mechanics, a shop to aquire new cards, enemies, towers and buff cards as well as a set of cards that allow to interact with the gameplay itself. It is based on the ggez library.</description>
    </item>
    
    <item>
      <title>Nautilus - Fuzzing with Grammars</title>
      <link>https://hexgolems.com/2018/12/nautilus---fuzzing-with-grammars/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2018/12/nautilus---fuzzing-with-grammars/</guid>
      <description>View On Github
Nautilus   Authors: Cornelius Aschermann, Tommaso Frassetto, Thorsten Holz, Patrick Jauernig, Ahmad-Reza Sadeghi, Daniel Teuchert
Nautilus is a feedback fuzzer inspired by AFL. However it allows to specify a grammar. Using this grammar, the fuzzer generates and internally uses the abstract syntax tree of the input. This also allows for very complex mutations. Then it converts the tree to the actual input. Knowing the exact tree shape greatly improves the performance for highly structured input formats, such as many text formats and programming languages.</description>
    </item>
    
    <item>
      <title>Redqueen</title>
      <link>https://hexgolems.com/2018/12/redqueen/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2018/12/redqueen/</guid>
      <description>View On Github
Redqueen   Authors: Cornelius Aschermann, Sergej Schumilo, Tim Blazytko, Robert Gawlik, Thorsten Holz
Redqueen is a fast general purpose fuzzer for x86 binary applications. It can automatically overcome checksums and magic bytes without falling back to complex and fragile program analysis techniques, such as symbolic execution. It works by observing the arguments to function calls and compare instructions via virtual machine introspection. Observed values are used to provide inputs specific mutations.</description>
    </item>
    
    <item>
      <title>Syntia</title>
      <link>https://hexgolems.com/2017/12/syntia/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/12/syntia/</guid>
      <description>View On Github
Syntia   Authors: Tim Blazytko, Moritz Contag, Cornelius Aschermann, Thorsten Holz
Syntia uses a Monte Carlo Tree Search based approach to program syntheses to learn program semantics from input/output examples. While synthesizing semantics from input/output examples only works for simple targets, it is extremely robust to common obfuscation schemes. As a consequence it is highly useful to deobfuscate the custom instruction sets from common VM based obfuscators such as Themida or VMProtect.</description>
    </item>
    
    <item>
      <title>kAFL</title>
      <link>https://hexgolems.com/2017/08/kafl/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/08/kafl/</guid>
      <description>View On Github
kAFL   Authors: Sergej Schumilo, Cornelius Aschermann, Robert Gawlik, Sebastian Schinzel, Thorsten Holz
kAFL is a blazing fast x86-64 VM kernel fuzzing framework with performant VM reloads for Linux, MacOS and Windows. It works by running the target operating system inside a hardware accelerated VM, giving it full controll over the environment. This very helpfull to properly recover from crashes. Intels Processor Trace (Intel PT) feature is used to obtain coverage information from the code running inside of the VM.</description>
    </item>
    
    <item>
      <title>Interval Tree</title>
      <link>https://hexgolems.com/2017/05/interval-tree/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/05/interval-tree/</guid>
      <description>View On Github
When implementing analysis software for memory dumps one often needs to store information on ranges of memory. For example, one might want to store ranges that represent basic blocks or functions, in code or memory allocations and type information in memory dumps. Afterwards one might want to answer queries such as &amp;ldquo;give me all allocations intersecting some range (x,y)&amp;rdquo;. In particular, this crate can be used to create better hex editor views, incorporating additional information.</description>
    </item>
    
    <item>
      <title>Loaded Dice</title>
      <link>https://hexgolems.com/2017/02/loaded-dice/</link>
      <pubDate>Wed, 01 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2017/02/loaded-dice/</guid>
      <description>View On Github
Sometimes you need to sample from a set of options. This crate allows you to sample from discrete probability distributions efficiently (O(1) per sample).
It implements a random sampler implementing based on the alias method (https://en.wikipedia.org/wiki/Alias_method). One uses it by passing a vector of probabilites to the constructor. The constructor builds a data structure in O(n*n*log(n)) (Note: It would be quite possible to implement this in O(n*log(n)), however for reasonable sized number of values this method is faster than using the more effictient data strucutres.</description>
    </item>
    
    <item>
      <title>SMT Solver Workshop</title>
      <link>https://hexgolems.com/2016/08/smt-solver-workshop/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/08/smt-solver-workshop/</guid>
      <description>View On Github
This is a one day Workshop on using SMT solvers for reverse engineering I gave at the Honeynet Project Annual Workshop in 2016. It contains the full slides, as well as the tasks and solutions. It teaches the basics of how program behavior is encoded in SMT formulas (more precisely, quantifier free theory of bitvectors - no theory of arrays / separation logic content in a one day workshop, sorry) and how one can use these formulas to get answers to questions about low level program behavior.</description>
    </item>
    
    <item>
      <title>Pwgen</title>
      <link>https://hexgolems.com/2016/03/pwgen/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/03/pwgen/</guid>
      <description>View On Github
pwgen.rb A better pwgeneration / file checksuming tool that uses the algorithm discussed in XKCD 936 to create highly secure and memorable passwords. When generating passwords, it allows to specify the strength of the password in bits. Additionally, it can be used to generate multiple passwords for different accounts/usecases from the same master password, to compare files by means of their fingerprint and to memorize fingerprints of arbitrary files (e.</description>
    </item>
    
    <item>
      <title>RDBG</title>
      <link>https://hexgolems.com/2016/03/rdbg/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/03/rdbg/</guid>
      <description>View On Github
RDBG RDBG is a ruby library that provides binary level debug access to processes.
it wraps the ptrace api to control the target (and read registers), it uses the /proc/$pid/mem and /proc$pid/mapping interfaces to allow proper access to the targets memory and it allows to set breakpoints. Using ptrace to inject breakpoints is actually suprisingly complicated and requires a somewhat complex statemachine to handle events like singlestepping on a breakpoint or capturing signals in combination with breakpoints.</description>
    </item>
    
    <item>
      <title>Indika</title>
      <link>https://hexgolems.com/2016/01/indika/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/01/indika/</guid>
      <description>View On Github
In reverse engineering, one often tries to identify well known functions in a stripped and statically linked binary. It is often possible to generate fingerprints for functions and match them against a debug build of the same libraries. Current approaches such as FLIRT signatures typically require a debug build with very similar compiler options. Additionally most current approaches require a one to one comparision between all pairs of functions.</description>
    </item>
    
    <item>
      <title>Reverse Game Of Life</title>
      <link>https://hexgolems.com/2015/04/reverse-game-of-life/</link>
      <pubDate>Wed, 01 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2015/04/reverse-game-of-life/</guid>
      <description>View On Github
Ever wanted to create a preimage of an arbitrary Game Of Life pattern? Running a simulated version of the game of life is very simple. However, as GOL is in fact turing complete, running it backwards is rather hard. In fact we know that there are so called garden of eden patterns that do not have any predecsessor. If one restricts the world to a fixed size, GOL is still able to compute arbitrary boolean functions.</description>
    </item>
    
    <item>
      <title>Pint</title>
      <link>https://hexgolems.com/2014/10/pint/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2014/10/pint/</guid>
      <description>View On Github
Pint is a PIN tool that exposes the PIN API to lua scripts. Pint runs on 64 bit Ubuntu and 32 bit Windows XP, it should run on 32 bit Ubuntu and 64 bit XP as well but this is yet untested.
PIN is a dynamic instrumentation engine developed by Intel. Basically, it is a JIT compiler for binaries. It will disassemble the binary, one basic block at a time, and recompile it with additional instructions inserted at arbitrary positions.</description>
    </item>
    
    <item>
      <title>SchemDBG</title>
      <link>https://hexgolems.com/2014/10/schemdbg/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2014/10/schemdbg/</guid>
      <description>View On Github
SchemDBG SchemDBG is a back-end agnostic debugger front-end that focuses on debugging binaries without access to the source code.
SchemDBG grew from the frustration with reversing in Linux environments (e.G. no proper binary-only-frontends for GDB). Currently, SchemDBG features a plain GDB server back-end and a PIN based back-end running on both 32 and 64 bit binaries in a Ubuntu host. SchemDBG hasn&amp;rsquo;t been tested with the PIN back-end on a Windows host but the PIN debug server works under windows #17.</description>
    </item>
    
    <item>
      <title>Brainfuck JIT</title>
      <link>https://hexgolems.com/2014/07/brainfuck-jit/</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2014/07/brainfuck-jit/</guid>
      <description>View On Github
A Compiler and JITer for brainfuck based on LLVM - build in literate ruby. It should be noted that this implementation produces horribly insecure binaries, and easily allows to overflow the programs memory, as it was used during a CTF exercise.

   &amp;#182;  Disclaimer
This is the commented version of my little Brainfuck compiler, The code is meant for educational purpose. Please note that this compiler is NOT save.</description>
    </item>
    
    <item>
      <title>Battlefleet</title>
      <link>https://hexgolems.com/2013/08/battlefleet/</link>
      <pubDate>Thu, 01 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2013/08/battlefleet/</guid>
      <description>View On Github
In Battlefleet a turn based strategy game, two players wage a battle in space. Both player plan their round independently, than the plans are executed in realtime (Play it Here). The game was written in CoffeScript using Crafty.js. It features multiple spaceships with different maneuverability and weapon characteristics and multiple levels, including a tutorial. We submitted it to the 27th Ludum dare competition, and unfortunately couldn&amp;rsquo;t find the time to add AI enemies.</description>
    </item>
    
    <item>
      <title>Azure VM</title>
      <link>https://hexgolems.com/2012/12/azure-vm/</link>
      <pubDate>Sat, 01 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2012/12/azure-vm/</guid>
      <description>View On Github
This is a small custom VM written in golang that was used as a service during the 2012 RWTH-CTF. It features a very RISC architecture (no stack operations, no call instructions..), and a very powerful macro assembler that allows to use high level constructs such as if/then/else or functions. The goal behind this challenge was to reverse engineer the target application given only in bytecode. Due to the very verbose nature of the instruction set, this benefits greatly from some pattern matching to undo the macro assemblers instructions.</description>
    </item>
    
    <item>
      <title>CodeWars</title>
      <link>https://hexgolems.com/2011/10/codewars/</link>
      <pubDate>Sat, 01 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2011/10/codewars/</guid>
      <description>View On Github
A custom CPU, a ring shaped memory and instruction pointer relative addressing. Two programs enter, one program leaves. A deadly low level programming competition to overwrite your opponents memory.
In contrast to the original Corewars our custom CPU has some modern features, such as registers. We provide a debugger that allows to singlestep and inspect your fighters execution in the core. If you need to test your bot against another bot, there is a profiler that allows you to perform many battles in short amount of time.</description>
    </item>
    
  </channel>
</rss>