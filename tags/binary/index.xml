<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary on Hexgolems</title>
    <link>https://hexgolems.com/tags/binary/</link>
    <description>Recent content in Binary on Hexgolems</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Mar 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hexgolems.com/tags/binary/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>RDBG</title>
      <link>https://hexgolems.com/2016/03/rdbg/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/03/rdbg/</guid>
      <description>View On Github
RDBG RDBG is a ruby library that provides binary level debug access to processes.
it wraps the ptrace api to control the target (and read registers), it uses the /proc/$pid/mem and /proc$pid/mapping interfaces to allow proper access to the targets memory and it allows to set breakpoints. Using ptrace to inject breakpoints is actually suprisingly complicated and requires a somewhat complex statemachine to handle events like singlestepping on a breakpoint or capturing signals in combination with breakpoints.</description>
    </item>
    
    <item>
      <title>Indika</title>
      <link>https://hexgolems.com/2016/01/indika/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2016/01/indika/</guid>
      <description>View On Github
In reverse engineering, one often tries to identify well known functions in a stripped and statically linked binary. It is often possible to generate fingerprints for functions and match them against a debug build of the same libraries. Current approaches such as FLIRT signatures typically require a debug build with very similar compiler options. Additionally most current approaches require a one to one comparision between all pairs of functions.</description>
    </item>
    
    <item>
      <title>Pint</title>
      <link>https://hexgolems.com/2014/10/pint/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2014/10/pint/</guid>
      <description>View On Github
Pint is a PIN tool that exposes the PIN API to lua scripts. Pint runs on 64 bit Ubuntu and 32 bit Windows XP, it should run on 32 bit Ubuntu and 64 bit XP as well but this is yet untested.
PIN is a dynamic instrumentation engine developed by Intel. Basically, it is a JIT compiler for binaries. It will disassemble the binary, one basic block at a time, and recompile it with additional instructions inserted at arbitrary positions.</description>
    </item>
    
    <item>
      <title>SchemDBG</title>
      <link>https://hexgolems.com/2014/10/schemdbg/</link>
      <pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2014/10/schemdbg/</guid>
      <description>View On Github
SchemDBG SchemDBG is a back-end agnostic debugger front-end that focuses on debugging binaries without access to the source code.
SchemDBG grew from the frustration with reversing in Linux environments (e.G. no proper binary-only-frontends for GDB). Currently, SchemDBG features a plain GDB server back-end and a PIN based back-end running on both 32 and 64 bit binaries in a Ubuntu host. SchemDBG hasn&amp;rsquo;t been tested with the PIN back-end on a Windows host but the PIN debug server works under windows #17.</description>
    </item>
    
    <item>
      <title>CodeWars</title>
      <link>https://hexgolems.com/2011/10/codewars/</link>
      <pubDate>Sat, 01 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://hexgolems.com/2011/10/codewars/</guid>
      <description>View On Github
A custom CPU, a ring shaped memory and instruction pointer relative addressing. Two programs enter, one program leaves. A deadly low level programming competition to overwrite your opponents memory.
In contrast to the original Corewars our custom CPU has some modern features, such as registers. We provide a debugger that allows to singlestep and inspect your fighters execution in the core. If you need to test your bot against another bot, there is a profiler that allows you to perform many battles in short amount of time.</description>
    </item>
    
  </channel>
</rss>